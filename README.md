# **소쿠리의 스터디**
> + 더이상 미룰수없어요.. 저의 공부..
> + 명서인 이펙티브 자바 늘 시도하다가 실패하는데요.. 
> + 2022년 호랑이의 해니까 `호랑이소쿠리` 도전해보겠습니다!!!!!!!
----
## **책 소개**

Effective Java 3/E - 조슈아 블로크

## **이것만은 지키자**
1. 하루에 적어도 아이템 1개씩은 공부
2. 거짓말은 치지말자...

## **목차**
### *2장 객체생성과 파괴*
[아이템1. 생성자대신 정적 팩터리 메서드를 고려하라](##-아이템1.-생성자대신-정적-팩터리-메서드를-고려하라)



---
## **아이템1. 생성자대신 정적 팩터리 메서드를 고려하라**
클라이언트가 클래스의 인스턴스를 얻는 전통적인 수단은 `public 생성자` 다.  
하지만 알아둬야할 기법이 하나 더 있다.
#### `정적 팩터리 메서드 (static factory method)`
클래스의 인스턴스를 반환하는 단순  정적 메서드
>[예제] 기본타입인 `boolean` 값을 받아 `Boolean 객체참조` 로 변환
##### Boolean.valueOf(boolean)
``` java
public static Boolean valueOf(boolean b){
    return b ? Boolean.TRUE : Boolean.FALSE; 
    // boolean b의 값이 true이면 Boolean의 TRUE, false이면 Boolean의 FALSE 리턴
}
```
### **장점**
1. **이름을 가질 수 있다.**  
    생성자에 넘기는 매개변수와 생성자 자체만으로는 반환되는 객체의 특성을 제대로 설명하지 못한다.  
    이름만 잘 지으면 반환될 객체의 특성을 쉽게 묘사할 수 있다는것!  
    > 값이 소수인 BigInteger를 반환한다

    #### *생성자 : BigInteger(int, int, Random)*
    : 하나의 시그니처로는 생성자를 하나만 만들수있다.  
    입력 매개변수들의 순서를 다르게 한 생성자를 추가하는 방법이 있지만 좋지않은 발상이다.  
    그런 경우 각 생성자마다 무슨 객체를 생성하는지 모르니까 문서를 일일이 참고하지않는다면..  
    엉뚱한 생성자를 호출 할 수 있다.
    #### *정적 팩터리 메서드 : BigInteger.probablePrime (JAVA 4)*
    한 클래스에 시그니처가 같은 생성자가 여러개 필요한 경우 정적팩터리메서드로 변경하고 이름을 명확히!

 2. **호출될 마다 인스턴스를 새로 생성하지는 않아도 된다.**  
    이 덕분에 [불변 클래스(immutable class)](##-아이템17.-변경가능성을-최소화하라)는 아래의 방법으로 불필요한 객체생성을 피할수있다.  
        * 인스턴스를 미리 만들어 놓는다.  
        * 새로 생성한 인스턴스를 캐싱하여 재활용한다.  
    * 또한 동치인 인스턴스가 단 하나뿐임을 보장할 수 있다.
            >   a == b 일 때만 a.eqauls(b) 가 성립된다.      
    * 대표적인 예로 [Boolean.valueOf(boolean)](#####-Boolean.valueOf(boolean))메서드는 객체를 아예 생성하지않는다.   
    -> (특히 생성비용이 큰) 같은 객체가 자주 요청되는 상황이라는 성능을 끌어올려준다.  
    (`플라이웨이트 패턴`: 이와 유사함)
    > `인스턴스 통제 클래스 (instance-controlled-class)` 
    >> 반복되는 요청에 같은 객체를 반환하여 인스턴스의 생명주기를 철저히 통제할 수 있다.  
    >>>플라이웨이트 패턴의 근간, [열거타입](##-아이템34.-int-상수-대신-열거-타입을-사용하라)은 인스턴스가 하나만 만들어짐을 보장한다.
    * 인스턴스를 통제하는 이유는?  
    클래스를 [싱글톤(singleton)](##-아이템3.-private-생성자나-열거-타입으로-싱글턴임을-보증하라) 또는 [인스턴스화 불가(noninstaniable)](##-아이템4.-인스턴스화를-막으려거든-private-생성자를-사용하라)로 만들수 있다.

3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.  
   반환될 객체의 클래스를 자유롭게 선택할수있게하는 엄청난 유연성!!
   * API 생성시 구현 클래스를 공개하지않고도 그 객체를 반환할 수 있어 API 작게 유지가능  
     * [인터페이스 기반 프레임워크](##-아이템20.-추상-클래스보다는-인터페이스를-우선하라): 정적 팩터리 메서드의 반환 타입이 `인터페이스`
     * `자바 8 이전` : 인터페이스에 정적 메서드 선언 불가  
     이름이 **Type**인 인터페이스를 반환하는 정적 메서드가 필요하면   
     **Types**라는 (인스턴스화 불가인) 동반클래스를 만들어 그안에 정의하는것이 관례였다. 
    * `java.util.Collections 인스턴스화 불가 클래스`  
    핵심 인터페이스들에 수정불가나 동기화 등의 기능을 덧붙인 총 `45개의 유틸리티 구현체`등을 해당 클래스의 정적 팩터리 메서드를 통해 얻게 함  


      