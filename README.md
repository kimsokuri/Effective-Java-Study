# **소쿠리의 스터디**
> + 더이상 미룰수없어요.. 저의 공부..
> + 명서인 이펙티브 자바 늘 시도하다가 실패하는데요.. 
> + 2022년 호랑이의 해니까 `호랑이소쿠리` 도전해보겠습니다!!!!!!!
----
## **책 소개**

Effective Java 3/E - 조슈아 블로크

## **이것만은 지키자**
1. 하루에 적어도 아이템 1개씩은 공부
2. 거짓말은 치지말자...

## **목차**
### *2장 객체생성과 파괴*
[아이템1. 생성자대신 정적 팩터리 메서드를 고려하라](##-아이템1.-생성자대신-정적-팩터리-메서드를-고려하라)



---
## **아이템1. 생성자대신 정적 팩터리 메서드를 고려하라**
클라이언트가 클래스의 인스턴스를 얻는 전통적인 수단은 `public 생성자` 다.  
하지만 알아둬야할 기법이 하나 더 있다.
#### `정적 팩터리 메서드 (static factory method)`
클래스의 인스턴스를 반환하는 단순  정적 메서드
>[예제] 기본타입인 `boolean` 값을 받아 `Boolean 객체참조` 로 변환
##### Boolean.valueOf(boolean)
``` java
public static Boolean valueOf(boolean b){
    return b ? Boolean.TRUE : Boolean.FALSE; 
    // boolean b의 값이 true이면 Boolean의 TRUE, false이면 Boolean의 FALSE 리턴
}
```
### **장점**
1. **이름을 가질 수 있다.**  
    생성자에 넘기는 매개변수와 생성자 자체만으로는 반환되는 객체의 특성을 제대로 설명하지 못한다.  
    이름만 잘 지으면 반환될 객체의 특성을 쉽게 묘사할 수 있다는것!  
    > 값이 소수인 BigInteger를 반환한다

    #### *생성자 : BigInteger(int, int, Random)*
    : 하나의 시그니처로는 생성자를 하나만 만들수있다.  
    입력 매개변수들의 순서를 다르게 한 생성자를 추가하는 방법이 있지만 좋지않은 발상이다.  
    그런 경우 각 생성자마다 무슨 객체를 생성하는지 모르니까 문서를 일일이 참고하지않는다면..  
    엉뚱한 생성자를 호출 할 수 있다.
    #### *정적 팩터리 메서드 : BigInteger.probablePrime (JAVA 4)*
    한 클래스에 시그니처가 같은 생성자가 여러개 필요한 경우 정적팩터리메서드로 변경하고 이름을 명확히!

 2. **호출될 마다 인스턴스를 새로 생성하지는 않아도 된다.**  
    이 덕분에 [불변 클래스(immutable class)](##-아이템17.-변경가능성을-최소화하라)는 아래의 방법으로 불필요한 객체생성을 피할수있다.  
        * 인스턴스를 미리 만들어 놓는다.  
        * 새로 생성한 인스턴스를 캐싱하여 재활용한다.  
    * 또한 동치인 인스턴스가 단 하나뿐임을 보장할 수 있다.
            >   a == b 일 때만 a.eqauls(b) 가 성립된다.      
    * 대표적인 예로 [Boolean.valueOf(boolean)](#####-Boolean.valueOf(boolean))메서드는 객체를 아예 생성하지않는다.   
    -> (특히 생성비용이 큰) 같은 객체가 자주 요청되는 상황이라는 성능을 끌어올려준다.  
    (`플라이웨이트 패턴`: 이와 유사함)
    > `인스턴스 통제 클래스 (instance-controlled-class)` 
    >> 반복되는 요청에 같은 객체를 반환하여 인스턴스의 생명주기를 철저히 통제할 수 있다.  
    >>>플라이웨이트 패턴의 근간, [열거타입](##-아이템34.-int-상수-대신-열거-타입을-사용하라)은 인스턴스가 하나만 만들어짐을 보장한다.
    * 인스턴스를 통제하는 이유는?  
    클래스를 [싱글톤(singleton)](##-아이템3.-private-생성자나-열거-타입으로-싱글턴임을-보증하라) 또는 [인스턴스화 불가(noninstaniable)](##-아이템4.-인스턴스화를-막으려거든-private-생성자를-사용하라)로 만들수 있다.

3. **반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.**  
   반환될 객체의 클래스를 자유롭게 선택할수있게하는 엄청난 유연성!!
   * API 생성시 구현 클래스를 공개하지않고도 그 객체를 반환할 수 있어 API 작게 유지가능  
     * [인터페이스 기반 프레임워크](##-아이템20.-추상-클래스보다는-인터페이스를-우선하라): 정적 팩터리 메서드의 반환 타입이 `인터페이스`
     * `자바 8 이전` : 인터페이스에 정적 메서드 선언 불가  
     이름이 **Type**인 인터페이스를 반환하는 정적 메서드가 필요하면   
     **Types**라는 **(인스턴스화 불가인) 동반클래스**를 만들어 그안에 정의하는것이 관례였다. 
     * `자바 8 이후` : 인터페이스에 정적 메서드 선언 가능, `public 정적 멤버만 허용`   
     (인스턴스화 불가인) 동반클래스를 굳이 만들지 않음.  
     -> 동반클래스에 두었던 `public 정적 멤버들(필드, 클래스..)` 상당수를 그냥 인터페이스에 두면 된다.  
     * `자바 9` : 인터페이스에 정적 메서드 선언 가능  
      `public 정적 멤버, private 정적 멤버 메서드 가능` 

        |인터페이스 내부에 선언 가능한 멤버| `자바 8 이전` | `자바 8` | `자바 9` |
        | -------- | ----------- |----------- |----------- |
        | public 정적 멤버 필드  |X|O|O|
        | public 정적 멤버 메서드 |X|O|O|
        | public 정적 멤버 클래스 |X|O|O|
        | | | |
        | private 정적 멤버 필드 |X|X|X|
        | private 정적 멤버 메서드 |X|X|O|
        | private 정적 멤버 클래스 |X|X|X|
    * `java.util.Collections 인스턴스화 불가 클래스`  
    핵심 인터페이스들에 수정불가나 동기화 등의 기능을 덧붙인 총 `45개의 유틸리티 구현체`등을 해당 클래스의 `정적 팩터리 메서드`를 통해 얻게 함  
        > 45개의 클래스를 공개하지 않기 때문에 API를 훨씬 작게 만들수있다.  
        > 또한 API를 사용하기 위해 익혀야하는 개념과 난이도도 낮춤  
        > *프로그래머는 명시한 인터페이스대로 동작하는 객체를 얻는다는것이 명확함.*  
        > 즉, **정적 팩터리 메서드**를 사용하는 클라이언트는 얻은 객체를 [`인터페이스`](##-아이템64.-객체는-인터페이스를-사용해-참조하라) 만으로 다룬다.

4. **입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.**  
   반환하려는 객체가 `반환타입의 하위타입`이기만 하면 어떤 클래스의 객체를 반환하든 상관없다.  
   * [EnumSet 클래스](##-아이템36.-비트-필드-대신-EnumSet을-사용하라)  
   public 생성자 없이 오직 정적 팩터리 메서드만 제공한다.    
   클라이언트는 아래 두개의 클래스 존재를 모름~   
   그냥 호출할때 EnumSet 클래스의 속성을 가진 인스턴스가 내려오겠구나~ 생각할수있음  
    **OpenJDK** : 원소의 수에 따라 두가지 하위 클래스 중 하나의 인스턴스 반환  
      * 원소가 64개 이하 : *RegularEnumSet* 인스턴스 (`long 변수`로 관리)
      * 원소가 65개 이상 : *JumboEnumSet* 인스턴스 (`long 배열`로 관리)   
5. **정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.**  
   이런 유연함으로 `서비스 제공자 프레임워크(service provider framework)`를 만드는 근간이 된다.  
   서비스 제공자 프레임워크에서의 `제공자(provider)`는 **서비스의 구현체**다.  
   구현체들을 클라이언트에 제공하는 역할을 프레임워크가 통제  
   > 서비스 제공자 프레임워크(service provider framework)
   * **핵심 컴포넌트**
   1. `서비스 인터페이스 (service interface)` : 구현체의 동작을 정의  
   ex . JDBC - Connection 
   2. `제공자 등록 API (provider registration API)` : 제공자가 구현체를 등록시 사용  
    ex . JDBC - DriverManager.registerDriver 
   3. 💥`서비스 접근 API (service access API)` : 클라이언트가 서비스의 인스턴스를 얻을때 사용
      * 클라이언트는 원하는 구현체의 조건을 명시할수있다.
      * 조건을 명시하지 않으면 기본 구현체 or 지원하는 구현체들을 하나씩 돌아가며 반환한다.
      * 공급자가 제공하는것보다 더 풍부한 서비스 인터페이스를 반환할 수 있다.
        * 브릿지 패턴(Bridge pattern) (https://lktprogrammer.tistory.com/35)
 
      ex . JDBC - DriverManager.getConnection    
   4. `서비스 제공자 인터페이스(service provider interface)` : `서비스 인터페이스`의 **인스턴스를 생성**하는 팩터리 객체를 설명한다.  
   만약, 없다면 각 구현체를 인스턴스로 생성할때 [리플렉션](##-아이템65.-리플렉션보다는-인터페이스를-사용하라)을 사용해야 한다.   
    ex . JDBC - Driver
  
 
       
     
### **단점**  
1. **상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.**  
위에서 말한 [컬렉션 프레임워크의 유틸리티 구현 클래스](*-`java.util.Collections-인스턴스화-불가-클래스`)들은 상속할 수 없다.   
아래 기능을 구현하기 위해서는 제약을 지켜야지만 가능 (오히려 위 제약이 장점;)  
   1. 상속보다 [컴포지션](##-아이템18.-상속보다는-컴포지션을-사용하라)을 사용하도록 유도
   2. [불변타입](##-아이템17.-변경-가능성을-최소화하라)으로 만들기     
2. **정적 팩터리 메서드는 프로그래머가 찾기 어렵다**  
생성자처럼 API 설명에 명확하게 드러나지 않아서   
사용자는 정적 팩터리 메서드 방식 클래스를 인스턴스화할 방법을 알아내야한다.  
-> 알려진 규약을 통해 정적 팩터리 메서드 이름을 지어야한다.
> 정적 팩터리 메서드 명명 방식

* *from* : 매개변수를 하나 받아서ㅓ 해당 타입의 인스턴스를 반환하는 형변환 메서드
``` java
Date d = Date.from(instant);
```
* *of* : 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메서드 
``` java
Set<Rank> faceCards = EnumSet.of(JACK, QUEEN, KING); 
// 반환 인스턴스를 Set<Rank> 로 명시
```
* *valueOf* : from과 of의 더 자세한 버전
``` java
BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);
// 어떤 타입의 인스턴스를 반환하는것을 원하는지 더 자세히 명시함. 여기선 MAX_VALUE
```
* *instance* 또는 *getInstance* : (매개변수를 받는다면) 매개변수로 명시한 인스턴스를 반환하지만,   
  `같은 인스턴스임을 보장하지않는다.`
``` java
StackWalker luke = StackWalker.getInstance(options);
```
* *create* 혹은 *newInstance* : *instance* 또는 *getInstance*와 같지만,   
  `매번 새로운 인스턴스를 생성해 반환함을 보장한다.`
``` java
Object newArray = Array.newInstance(classObject, arrayLen);
// 매개변수로 받은 클래스와 길이에 해당하는 늘 새로운 인스턴스를 반환한다.
```
* *getType* : *getInstance*와 같으나, 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 쓴다.   
  `"Type"은 팩터리 메서드가 반환할 객체의 타입을 써주면 된다.`
``` java
FileStore fs = Files.get"FileStore"(path);
// FileStore 클래스가 아닌 
// Files 클래스에 리턴값이 FileStore 인 팩터리 메서드가 정의되어 있음.
```
* *newType* : *newInstance*와 같으나, 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 쓴다.   
  `"Type"은 팩터리 메서드가 반환할 객체의 타입을 써주면 된다.`
``` java
BufferdReader br = Files.new"BufferedReader"(path);
// BufferReader 클래스가 아닌 
// Files 클래스에 리턴값이 BufferReader 인 팩터리 메서드가 정의되어 있음.
```
* *type* : *getType* 과 *newType*의 간결한 버전  
``` java
List<Complaint> litany = Collections."list"(legacyLitany);
// Collections 유틸리티 클래스에서 list 인스턴스를 반환한다.
```

❗ 정리
```
정적 팩터리 메서드와 public 생성자는 각자의 쓰임새가 있으니 
상대적인 장단점을 이해하고 사용하는 것이 좋다!
하지만 정적 팩터리 메서드를 사용하는게 유리한 경우가 많으니까 무작정 생성자 쓰지는 말자!